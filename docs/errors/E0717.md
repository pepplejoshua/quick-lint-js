# E0717: using a '.' after a '?.' might fail, since '?.' might return 'undefined'

```config-for-examples
{
  "globals": {
  }
}
```

In Javascript, the `?.` operator performs a conditional access only if the left-hand side is not `null` or `undefined`. If the left-hand side is `null` or `undefined`, the expression returns `undefined` and the right-hand side is not evaluated. Using it suppresses the error that would otherwise be thrown if the left-hand side were `null` or `undefined` and the operator `.` were used instead. However, if the left-hand side is not `null` or `undefined`, the expression returns the value of the right-hand side, which may be `null` or `undefined`. If the right-hand side is `null` or `undefined`, using the `.` operator will throw an error:

```js
let a = { b: 1 };
let b = a?.b; // ok
let c = a?.b?.a; // ok
let d = a?.b?.a.c; // throws an error
```

In the example above, the last statement will throw an error, because `a.b` is not `null` or `undefined`, but `a.b.a` is `undefined`, and `undefined.c` throws an error.

This also affects optional chaining with function calls (`?.()`):

```js
let _a = (_arg) => {
  return; // so returns undefined
};

let e = _a?.(a)?.(_a)?.(a); // ok
let f = _a?.(a).b; // throws an error since _a(a) is undefined
```

and optional chaining with index expressions (`?.[]`) for the same reason:

```js
let g = [1, [2, { a: 3 }]];
let h = g?.[1]; // ok
let j = g?.[1]?.[2].b; // throws an error since g[1][2] is undefined
```

Replacing the `.` with `?.` will prevent the errors from being thrown at runtime:

```js
let d = a?.b?.a?.c; // ok
let f = _a?.(a)?.b; // ok
let j = g?.[1]?.[2]?.b; // ok
```
